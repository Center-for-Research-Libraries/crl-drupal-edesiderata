diff --git a/modules/salesforce_pull/salesforce_pull.module b/modules/salesforce_pull/salesforce_pull.module
index 1bcf058..ee5d33f 100644
--- a/modules/salesforce_pull/salesforce_pull.module
+++ b/modules/salesforce_pull/salesforce_pull.module
@@ -311,6 +311,8 @@ function salesforce_pull_process_records($sf_object) {
   foreach ($sf_mappings as $sf_mapping) {
     // Mapping object exists?
     $mapping_object = salesforce_mapping_object_load_by_sfid($sf_object['Id']);
+    // Allow other modules to define or alter the mapping object.
+    drupal_alter('salesforce_pull_mapping_object', $mapping_object, $sf_object, $sf_mapping);
     $exists = $mapping_object ? TRUE : FALSE;
     if ($exists && ($sf_mapping->sync_triggers & SALESFORCE_MAPPING_SYNC_SF_UPDATE)) {
       try {
diff --git a/modules/salesforce_push/salesforce_push.module b/modules/salesforce_push/salesforce_push.module
index c467381..6e1a8ed 100644
--- a/modules/salesforce_push/salesforce_push.module
+++ b/modules/salesforce_push/salesforce_push.module
@@ -120,6 +120,8 @@ function salesforce_push_sync_rest($entity_type, $entity, $mapping, $sf_sync_tri
 
   list($entity_id) = entity_extract_ids($entity_type, $entity);
   $mapping_object = salesforce_mapping_object_load_by_drupal($entity_type, $entity_id, TRUE);
+  // Allow other modules to define or alter the mapping object.
+  drupal_alter('salesforce_push_mapping_object', $mapping_object, $entity, $mapping);
 
   // Delete SF object.
   if ($sf_sync_trigger == SALESFORCE_MAPPING_SYNC_DRUPAL_DELETE) {
@@ -304,13 +306,15 @@ function salesforce_push_cron() {
     // Add entity id to array of pushed entities to check for duplicates later.
     $entity_ids[$item->data['entity_type']][] = $entity_id;
 
-    $mapping_object = salesforce_mapping_object_load_by_drupal($entity_type, $entity_id);
-
     if (!$use_soap) {
       salesforce_push_sync_rest($entity_type, $entity, $mapping, $item->data['trigger']);
       $queue->deleteItem($item);
       continue;
     }
+    
+    $mapping_object = salesforce_mapping_object_load_by_drupal($entity_type, $entity_id);
+    // Allow other modules to define or alter the mapping object.
+    drupal_alter('salesforce_push_mapping_object', $mapping_object, $entity, $mapping);
 
     if ($item->data['trigger'] == SALESFORCE_MAPPING_SYNC_DRUPAL_DELETE && $mapping_object) {
       $delete_list[$delta] = $mapping_object->salesforce_id;
diff --git a/salesforce.api.php b/salesforce.api.php
index bc158a2..01df8f9 100644
--- a/salesforce.api.php
+++ b/salesforce.api.php
@@ -31,6 +31,75 @@ function hook_salesforce_mapping_fieldmap_type_alter($fieldmap_type) {
 }
 
 /**
+ * Define or alter the mapping object during a pull.
+ *
+ * @param mixed $mapping_object
+ *   The mapping object that was detected based on existing mappings or FALSE
+ *   if no exisitng mapping object exists.
+ * @param array $sf_object
+ *   The salesforce object data that will be used in this pull.
+ * @param object $mapping
+ *   The salesforce mapping that will be used during the pull.
+ */
+function hook_salesforce_pull_mapping_object_alter(&$mapping_object, $sf_object, $mapping) {
+  // Do some prematching for incoming user pulls if we don't already have a
+  // match.
+  if (!$mapping_object && $sf_mapping->drupal_entity_type == 'user') {
+    // Run some complex custom prematching logic that searches for an existing
+    // Drupal user that is a match to the incoming Salesforce data.
+    $matched_user = mymodule_custom_sf_pull_prematch($sf_object, $mapping);
+    if ($matched_user) {
+      // If we have a match create mapping object on-the-fly and then reload it
+      // This means that the rest of the pull logic will target this matched
+      // user instead of creating a new one.
+      entity_create('salesforce_mapping_object', array(
+        'salesforce_id' => $sf_object['Id'],
+        'entity_type' => $sf_mapping->drupal_entity_type,
+        'entity_id' => $match->uid,
+        'last_sync_message' => t('User prematch on pull'),
+        'last_sync_status' => SALESFORCE_MAPPING_STATUS_SUCCESS
+      ))->save();
+      $mapping_object = salesforce_mapping_object_load_by_sfid($sf_object['Id'], TRUE);
+    }
+  }
+}
+
+/**
+ * Define or alter the mapping object during a push.
+ *
+ * @param mixed $mapping_object
+ *   The mapping object that was detected based on existing mappings or FALSE
+ *   if no exisitng mapping object exists.
+ * @param object $entity
+ *   The Drupal entity that is being pushed.
+ * @param object $mapping
+ *   The salesforce mapping that will be used during the push.
+ */
+function hook_salesforce_push_mapping_object_alter(&$mapping_object, $entity, $mapping) {
+  // Do some prematching for outgoing user pushes if we don't already have a
+  // match.
+  if (!$mapping_object && $sf_mapping->drupal_entity_type == 'user') {
+    // Run some complex custom prematching logic that queries Salesforce for an
+    // existing contact (beyond a basic external key comparison) that is a match
+    // to this Drupal user.
+    $matched_contact = mymodule_custom_sf_push_prematch($entity, $mapping);
+    if ($matched_contact) {
+      // If we have a match create mapping object on-the-fly and then reload it
+      // This means that the rest of the push logic will target this matched
+      // contact instead of creating a new one.
+      entity_create('salesforce_mapping_object', array(
+        'salesforce_id' => $sf_object['Id'],
+        'entity_type' => $sf_mapping->drupal_entity_type,
+        'entity_id' => $match->uid,
+        'last_sync_message' => t('User prematch on push'),
+        'last_sync_status' => SALESFORCE_MAPPING_STATUS_SUCCESS
+      ))->save();
+      $mapping_object = salesforce_mapping_object_load_by_drupal('user', $entity->uid, TRUE);
+    }
+  }
+}
+
+/**
  * Alter parameters mapped to a Salesforce object before syncing to Salesforce.
  *
  * @param array $params
