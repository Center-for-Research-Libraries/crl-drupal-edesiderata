<?php


// Set a 'salt' value that we can use for securing key data in cookie hashes
define('CRL_COOKIE_SALT', '28hsY73Hdfs');
// Set general crl cookie lifetime
define('CRL_COOKIE_LIFETIME', 60*60*24*5);


/**
 * Implementation of hook_boot().
 * 
 * This is where the real magic happens. Here, during the bootstrap, we check 
 * to see if the current user has member access based on their IP, and if so
 * we given them a member role and ensure they are not shown any cached data.
 * 
 * IMPORTANT NOTE: In order for the "$conf['cache'] = CACHE_DISABLED;" 
 * statements to work the dymanic_cache module must be installed.
 */
function crl_access_by_ip_boot() {
  global $conf;
  global $user;
  // Start a timer that we can use to see how long the member check process
  // takes
  $mtime = microtime();
  $mtime = explode(" ",$mtime);
  $mtime = $mtime[1] + $mtime[0];
  $user->crl_timer_start = $mtime; 
  $ip = ip_address();
  // If we detect a crawler/spider, then don't run checks (no need for 
  // the overhead in these cases), but log the hit.
  if (crl_access_by_ip_check_if_spider()) {
    $member_data['member'] = 'nonmember';
    $member_data['id'] = 10002; // Crawler code
    $member_data['name'] = 'crawler';
    $user->crl_member_data = $member_data;
    _crl_access_by_ip_stats(TRUE);
    return;
  } 
  // Check if we already have member access details stored in a cookie for this 
  // user. This check will fail if their IP has changed since the last check, 
  // and in this case we'll need to re-test thier ip (which is by design).
  if (isset($_COOKIE['crl_member_data_key']) && isset($_COOKIE['crl_member_data'])) {
    // Confirm member data is valid for this IP.
    if (md5($_COOKIE['crl_member_data'] . $ip . CRL_COOKIE_SALT) == $_COOKIE['crl_member_data_key']) {
      $member_data = unserialize(urldecode($_COOKIE['crl_member_data']));
      if (is_array($member_data)) {
        // Do some sanitizing on the values, just in case.
        foreach ($member_data as $key => $value) {
          $member_data[$key] = strip_tags(htmlspecialchars($value));
        }
        $user->crl_member_data = $member_data;
        // If we have a member, react accordingly.
        if ($member_data['member'] === 'member') {    
          // Be sure cache is disabled for this page and grant member role.
          $conf['cache'] = CACHE_DISABLED; // Will only work with with dynamic_cache enabled!
          $user->roles[variable_get('crl_access_by_ip_options_roles', FALSE)] = "member";
          _crl_access_by_ip_stats(TRUE);
          return;
        }
        // If we don't have a member, just record stats.
        else {
          _crl_access_by_ip_stats(TRUE);
          return;
        }
      }
    }
  }
  // If we get here we don't have cookie-based member data for this user, so we
  // have to run the full IP check to the DDS server.
  require_once('./includes/common.inc'); // Needed as we are still in bootstrap
  $member_data = _crl_access_by_ip_check();
  $user->crl_member_data = $member_data;
  // Set the cookie so we can recognize this user easier next time, but only
  // if there was not an error.
  if ($member_data['id'] != 10001) { // Error code
    $member_data_encoded = urlencode(serialize($member_data));
    $member_data_key = md5($member_data_encoded . $ip . CRL_COOKIE_SALT);
    setcookie('crl_member_data', $member_data_encoded, time()+CRL_COOKIE_LIFETIME, '/');
    setcookie('crl_member_data_key', $member_data_key, time()+CRL_COOKIE_LIFETIME, '/');
  }
  if ($member_data['member'] === 'member') {
    // Be sure cache is disabled for this page and grant member role
    $conf['cache'] = CACHE_DISABLED; // Will only work with with dynamic_cache enabled!
    $user->roles[variable_get('crl_access_by_ip_options_roles', FALSE)] = "member";
  }
  _crl_access_by_ip_stats();
}


/**
 * Run an actual IP check to DDS server.
 * 
 * This function runs the formal IP check. It creates a simple http request
 * that includes the IP address as a parameter and passes it to DDS. The
 * response must be properly formatted XHTML that we can parse the member status
 * and other member details from.
 * 
 * The response we parse from DDS follows a custom format where the formal 
 * data is wrapped in <span> tags. If we could set up DDS to formally deal with
 * XML-RPC calls, this function could be built to instead send/recieve the info
 * via XML-RPC (may require services module, etc.).
 *
 */
function _crl_access_by_ip_check() {
  // Prep the request.
  $ip = ip_address();
  $target_url = variable_get('crl_access_by_ip_options_url', NULL);
  $request_method = 'GET';
  $request_retry = 3; // Number of redirects to follow
  $timeout = 1; // Max time (seconds) we can allow our check to delay a page load
  $query = 'ip=' . $ip;
  $data ='';  // not required for GET
  $request_headers = array();  // not required for GET
  $request_url = $target_url . '?' . $query;
  // Send the request.
  $request_result = drupal_http_request($request_url, $request_headers, $request_method, $data, $request_retry);
  // Verify and parse the request results.
  $response = 0;
  $member_data = array();
  if (is_object($request_result)) {
    if ($request_result->status_message == "OK" && isset($request_result->data)) {
      // Parse the result for our specific member data.
      $matches1 = '';
      $matches2 = '';
      $matches3 = '';
      $response1 = preg_match('/(\<span class\=\"member_result\"\>)(.*)(\<\/span\>)/siU', $request_result->data, $matches1);
      $response2 = preg_match('/(\<span class\=\"member_result_id\"\>)(.*)(\<\/span\>)/siU', $request_result->data, $matches2);
      $response3 = preg_match('/(\<span class\=\"member_result_name\"\>)(.*)(\<\/span\>)/siU', $request_result->data, $matches3);
      // Only continue if we at least have a clear response on the member status
      if ($response1) {
        $member_data['member'] = $matches1[2]; // TRUE/FALSE string
        if ($response2) {
          $member_data['id'] = (int)$matches2[2];
        }
        if ($response3) {
          $member_data['name'] = $matches3[2];
        }
        // Clean-up $member_data       
        if ($member_data['member'] == 'FALSE') { // KNOWN nonmember
          $member_data['member'] = 'nonmember'; // Convert
          $member_data['id'] = (int)10000; // KNOWN nonmember code
          $member_data['name'] = 'na';
        }
        if ($member_data['member'] == 'TRUE') {
          $member_data['member'] = 'member'; // Convert
          if (empty($member_data['name'])) {
            $member_data['name'] = 'Center for Research Libraries';
          }
        }
        return $member_data;
      }  
    } 
  }
  // If we get here it means that we could not successfully gather the member
  // data via our XHTML call.
  $member_data['member'] = 'nonmember';
  $member_data['id'] = 10001; // Error code
  $member_data['name'] = 'na';
  return $member_data;
}


/**
 * Implementation of hook_nodeapi().
 * 
 * This is only used to set messages about member access. When loading a node
 * see if its access is controlled by our member role. If so, and if the user
 * does not have member access, display appropriate messages.
 */
function crl_access_by_ip_nodeapi(&$node, $op) {
  if ($op == 'load') {
    global $user;
    // See if we are on a views page.
    static $views_page = FALSE;
    if (!$views_page) {
      $views_page = views_get_page_view();
    }
    // See if we have access to this node.
    if (!node_access('view', $node)) {
      // If we don't have access see if the access is restricted specifically 
      // because of the members role, and set message as needed.
      $user_temp = clone $user;
      $user_temp->roles[variable_get('crl_access_by_ip_options_roles', FALSE)] = "member";
      if (node_access('view', $node, $user_temp)) { // "Member" role does give access
        // Only display any messages once per page-load. This prevents view
        // lists from triggering a message per list item, etc.
        static $displayed_access_messages = FALSE;
        if (!$displayed_access_messages) {        
          if (is_object($views_page)) {
            drupal_set_message(t("Some content listed below is only available to CRL members."), error);
          }
          else {
            drupal_set_message(t("Access to this content is restricted to users visiting this page from a CRL member institution."), error);
          }
          $displayed_access_messages = TRUE;
        }
        // Set a flag on the node in case other modules want to use this info
        // (e.g. special message by a restricted node on a view list).
        $node->member_restricted = TRUE;
      }
    }
  }
}


// Simple helper function to log stats about each hit to the DB.
function _crl_access_by_ip_stats($cached = FALSE) {
  // Stop the timer that checks how long the member check process takes
  global $user;
  $mtime = microtime();
  $mtime = explode(" ",$mtime);
  $mtime = $mtime[1] + $mtime[0];
  $check_time = $mtime - $user->crl_timer_start;
  $member_data = $user->crl_member_data;
  $sql = '';
  if ($cached) {
    $sql = 'INSERT INTO crl_member_hits (member_id, member_name, hits_cached, hits_not_cached, timer_cached, timer_not_cached) VALUES (' . $member_data['id'] . ', "' . $member_data['name'] . '", ' . 1 . ', ' . 0 . ', ' . $check_time . ', ' . 0 . ') ON DUPLICATE KEY UPDATE hits_cached = hits_cached + 1, timer_cached = timer_cached + ' . $check_time;
  }
  else {
    $sql = 'INSERT INTO crl_member_hits (member_id, member_name, hits_cached, hits_not_cached, timer_cached, timer_not_cached) VALUES (' . $member_data['id'] . ', "' . $member_data['name'] . '", ' . 0 . ', ' . 1 . ', ' . 0 . ', ' . $check_time . ') ON DUPLICATE KEY UPDATE hits_not_cached = hits_not_cached + 1, timer_not_cached = timer_not_cached + ' . $check_time;
  }
  db_query($sql);
}


/**
 * Implementation of hook_token_values().
 * 
 * Here we set new tokens that can be used to report member details. Any
 * modules that use tokens can then take advantage of this data.
 */
function crl_access_by_ip_token_values($type, $object = NULL, $options = array()) {
  if ($type == 'user') {
    global $user;
    $tokens['member_status'] = $user->crl_member_data['member'];
    $tokens['member_institution'] = $user->crl_member_data['name'];
    $tokens['member_id'] = $user->crl_member_data['id'];
    return $tokens;
  }
}


/**
 * Implementation of hook_token_list().
 * 
 * Set listing details for our new member status tokens.
 */
function crl_access_by_ip_token_list($type = 'all') {
  if ($type == 'user' || $type == 'all') {
    $tokens['user']['member_status'] = t("The user's CRL member status");
    $tokens['user']['member_institution'] = t("The user's CRL member institution (if member)");
    $tokens['user']['member_id'] = t("The CRL member ID for an institution (if member)");
    return $tokens;
  }
}


/**
 * Implementation of hook_form_alter().
 * 
 * Add some configuration details to the admin interface.
 */
function crl_access_by_ip_form_alter(&$form, &$form_state, $form_id) {
  if ($form_id == crl_admin_settings) {
    $form['crl_access_by_ip_options'] = array(
      '#type' => 'fieldset',
      '#title' => t('Access-by-IP Options'),
      '#description' => t('Options related to the member access-by-ip feature'),
      '#collapsible' => TRUE,
      '#collapsed' => FALSE,
      '#weight' => 0,
      );
    $form['crl_access_by_ip_options']['crl_access_by_ip_options_url'] = array(
      '#type' => 'textfield',
      '#title' => t('Lookup URL'),
      '#default_value' => variable_get('crl_access_by_ip_options_url', NULL),
      '#description' => t('The URL for IP validation'),
      );
    $form['crl_access_by_ip_options']['crl_access_by_ip_options_roles']  = array(
      '#title' => t('Member Role'),
      '#type' => 'select',
      '#options' => user_roles(),
      '#default_value' => variable_get('crl_access_by_ip_options_roles', 0),
      '#description' => t('Specify the member role that will be assigned to all users that pass the IP check (including anonmyous).'),
      );
  }
}


// Helper function to detect a spider. We do not use php's get_browser() as
// browsecap.ini may not be enabled.
function crl_access_by_ip_check_if_spider() {
  // Define spider list and use in preg_match
  $spiders = 'Spider|Crawler|Googlebot|Adsbot|Bingbot|DotBot|FeedFetcher|LinkWalker|QihooBot|Yammybot|Openbot|Slurp|msnbot|ia_archiver|Scooter|Teoma|Rambler|AbachoBOT|accoona|AcioRobot|ASPSeek|Dumbot|GeonaBot|Gigabot|Lycos|MSRBOT|Scooter|AltaVista|IDBot|eStyle|Scrubby|alexa|froogle|dotbot|inktomi|looksmart|InfoSeek|Spade|ZyBorg|rabaz|TechnoratiSnoop|Rankivabot|StackRambler';
  if (preg_match('/' . $spiders . '/i', $_SERVER['HTTP_USER_AGENT'])) {
    return TRUE;
  }
  return FALSE;
}
