<?php


/**
 * Implementation of hook_menu().
 * 
 * This defines the top of the menu tree for all Drupal admin options.
 */
function crl_helpers_menu() {
  $items = array();
  $items['admin/settings/crl'] = array(
    'title'            => 'CRL Customizations',
    'description'      => 'Administer CRL Customizations.',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('crl_admin_settings'),
    'access arguments' => array('administer site configuration'),
    'type'             => MENU_NORMAL_ITEM,
    'file' => 'crl_helpers.admin.inc',
  );
  $items['admin/settings/crl/main'] = array(
    'title'            => 'CRL Customizations',
    'description'      => 'Administer CRL Customizations.',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('crl_admin_settings'),
    'access arguments' => array('administer site configuration'),
    'type'             => MENU_DEFAULT_LOCAL_TASK,
    'file' => 'crl_helpers.admin.inc',
  );
  // Special "traffic control" page for Purchase Proposal SSO.
  $items['pp-sso'] = array(
    'title'            => 'CRL Purchase Proposal Access',
    'description'      => '',
    'page callback'    => 'crl_helpers_pp_sso',
    'access arguments' => array('access content'),
    'type'             => MENU_CALLBACK,
  );
  $items['admin/settings/crl/pp-sso'] = array(
    'title'            => 'Purchase Proposal SSO',
    'description'      => '',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('crl_helpers_pp_sso_settings'),
    'access arguments' => array('administer site configuration'),
    'type'             => MENU_LOCAL_TASK,
     'file' => 'crl_helpers.admin.inc',
  );
  $items['admin/settings/crl/pp-sso/main'] = array(
    'title'            => 'Settings',
    'description'      => '',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('crl_helpers_pp_sso_settings'),
    'access arguments' => array('administer site configuration'),
    'type'             => MENU_DEFAULT_LOCAL_TASK,
     'file' => 'crl_helpers.admin.inc',
  );
  $items['admin/settings/crl/pp-sso/validate'] = array(
    'title'            => 'Validate',
    'description'      => '',
    'page callback'    => 'crl_helpers_pp_sso_validate',
    'access arguments' => array('administer site configuration'),
    'type'             => MENU_LOCAL_TASK,
    'file' => 'crl_helpers.admin.inc',
  );
  return $items;
}



/*****************************************************************************
 * Old context stuff. May have links to CRL theme
 *****************************************************************************/

// Some constants.  Perhaps these should be module settings at some point
define('CRL_HELPERS_TOPIC_VID', 4); // The vocabulary ID of the 'Topic' 
                                    // taxonomy vocabulary.

// Pages with path aliases matching these paths are considered landing pages
// QUESTION: Is it best to implement this by matching paths or to look at the 
// page's location in a menu structure?
define('CRL_HELPERS_LANDING_PAGE_PATHS', <<<EOT
about
membership
collections
services
archiving-preservation
area-studies/camp
area-studies/lamp
area-studies/memp
area-studies/samp
area-studies/seam
area-studies/seemp
grn/gnarp
grn/cifnal
grn/afrinul
grn/hradp
grn/larrp
grn/trail
EOT
);



/**
 * Display help and module information
 * @param path which path of the site we're displaying help
 * @param arg array that holds the current path as would be returned from arg() function
 * @return help text for the path
 */
function crl_helpers_help() {
  $output = '';
  
  switch ($path) {
    case "admin/help#crl_helpers":
      $output = '<p>' . t("Provides helper functions, implements hooks to slightly alter default Drupal behavior, or encapsulates PHP snippets used throughout the site.") . '</p>';
      break;
  }
  return $output;
}




function crl_helpers_init() {
  //Disable sticky table headers if conditions met
  //if (variable_get('mymodulename_disable_sticky_js_headers', FALSE)) {
    drupal_add_js('Drupal.behaviors.tableHeader = function(){};', 'inline', 'footer');
  //}
  
    // Customize the user login/register/password page titles
    // Strings match the page titles as set in user_menu() so they are translated
    if (arg(0) == 'user' && arg(1) == 'register') {
      drupal_set_title(t('Register'));
    } elseif (arg(0) == 'user' && arg(1) == 'password') {
      drupal_set_title(t('Request new password'));
    } elseif (arg(0) == 'user' && arg(1) == 'login') {
      drupal_set_title(t('Log in'));
    } elseif (arg(0) == 'user' && arg(1) == '') {
      drupal_set_title(t('Log in'));
    }
      elseif (arg(0) == 'user' && arg(2) == 'profile') {
      drupal_set_title(t('Edit User Profile'));
    }
}




/**
 * Implementation of hook_e_mail_alter.
 *
 * This implementation gets rid of the Sender and Errors-To headers.  
 * These headers are, by default, set to the the e-mail address specified
 * at /admin/settings/site-information. The setting of these headers cause
 * problems when trying to subscribe to a listserv as the result of a Webform
 * submission.
 *
 * See http://drupal.org/node/461324#comment-1716972 for more about this behavior.
 */
function crl_helpers_mail_alter(&$message) {
  unset($message['headers']['Sender']);
  unset($message['headers']['Errors-To']);
}

/**
 * Return the name of the menu that contains a node's menu item.
 */
function crl_helpers_node_get_menu_name($node) {
  $menu_name = db_result(db_query_range("SELECT menu_name FROM {menu_links} WHERE link_path = 'node/%d' AND module = 'menu'", $node->nid, 0, 1));
  return $menu_name;
}

/**
 * Determines if the current page is a jstor page.
 *
 * This function will have to be modified if the JSTOR pages are ever
 * moved in the menu structure.
 */
function crl_helpers_is_jstor_page() {
  $is_jstor_page = FALSE;
  $active_trail = menu_get_active_trail();

  if (isset($active_trail[1]) &&
      strpos($active_trail[1]['title'], 'JSTOR') !== FALSE) {
    $is_jstor_page = TRUE;
  }

  return $is_jstor_page;
}

/**
 * Determines if the current page is a topic guide.
 *
 * This function will have to be modified if the Topic Guide URL paths
 * ever change.
 */
function crl_helpers_is_topic_guide() {
  $is_topic_guide = FALSE;
  $alias = drupal_get_path_alias($_GET['q']);

  if (drupal_match_path($alias, 'collections/topics/*')) {
    $is_topic_guide = TRUE;
  }

  if (drupal_match_path($alias, 'guide/*')) {
    $is_topic_guide = TRUE;
  }


  return $is_topic_guide;
}

/**
 * Determines if the current page is a news or events page.
 */
function crl_helpers_is_news_events_page() {
  if (arg(0) == 'node') {
    $node = node_load(arg(1));
    if (strpos(strtolower($node->type), 'news') !== FALSE) {
      return 'News';
    }
    if (strpos(strtolower($node->type), 'event') !== FALSE) {
      return 'Events';
    }
  }
  return FALSE;
}

/**
 * Determines if the current page is a news or events page.
 *
 * This function will have to be modified if the JSTOR pages are ever
 * moved in the menu structure.
 */
function crl_helpers_is_news_events_subpage() {
  $is_news_events_subpage = FALSE;

  $active_trail = menu_get_active_trail();

  // TODO: Finish implementing this.

  return $is_news_events_subpage;
}

/**


 * Determines if the current page is a landing page.
 *
 * Landing pages are pages at the top level of the navigation menu.
 */
function crl_helpers_is_landing_page() {
  $alias = drupal_get_path_alias($_GET['q']);

  $is_landing_page = drupal_match_path($alias, CRL_HELPERS_LANDING_PAGE_PATHS); 

  return $is_landing_page;
}

/**



/**


 * Determines if the current page is a review.
 *
 * 
 */
function crl_helpers_is_review() {
  $is_review = FALSE;
  $alias = drupal_get_path_alias($_GET['q']);

  if (drupal_match_path($alias, 'review/*')) {
    $is_review = TRUE;
  }
  return $is_review;
}

/**



 * Determines if the current page is a profile.
 *
 * 
 */
function crl_helpers_is_profile() {
  $is_profile = FALSE;
  $alias = drupal_get_path_alias($_GET['q']);

  if (drupal_match_path($alias, 'profile/*')) {
    $is_profile = TRUE;
  }
  return $is_profile;
}

function crl_helpers_can_edit() {
  $can_edit = FALSE;
  
  if(arg(0) == 'node' && is_numeric(arg(1))){
    //load $node object
    $node = node_load(arg(1));
    //check for node update access
    if (node_access("update", $node)){
      $can_edit = TRUE;
    }
  }

  
  return $can_edit;
}

/** 



 * Determines if the current page is GRN / AMP.
 *
 * 
 */
function crl_helpers_is_grn_amp() {
  $is_grn_amp = FALSE;
  $alias = drupal_get_path_alias($_GET['q']);

  if (drupal_match_path($alias, 'grn/*')) {
    $is_grn_amp = TRUE;
  }
  
   if (drupal_match_path($alias, 'area-studies/*')) {
    $is_grn_amp = TRUE;
  } 
  
  
  return $is_grn_amp;
}

/**



 * Return a page node's type based on it's position in the menu structure.
 *
 * There are a number of pieces of content in the CRL site that are implemented
 * using the Page content type, but differ in some ways from a "normal" page.
 * These "special" pages may require different theming or other handling.
 * Typically, taxonomy is used to distinguish such pages, but the CRL site
 * relies on the menu structure to organize the site and distinguish different
 * types of content.  This function returns a string identifying the "type" of
 * a page node based on its position in the menu structure.
 *
 * @param node page node object.
 *
 * @return string identifying the "type" of the page. 
 */
function crl_helpers_get_page_type() {
  if (crl_helpers_is_jstor_page()) {
    $page_type = 'jstor-title-list-page';
  }
  else if (crl_helpers_is_news_events_subpage()) {
    $page_type = 'news-events-sub-page';
  }


  else if (crl_helpers_is_landing_page()) {
    $page_type = 'landing-page';
  }


  else {
    $page_type = 'page';
  }
  
  return $page_type;
}

/**
 * Implementation of hook_token_list().
 */

function crl_helpers_token_list($type = 'all') {
  if ($type == 'global' || $type == 'all') {
    // We don't implement any global tokens yet.
  }

  if ($type == 'node' || $type == 'all') {
    // Node tokens here
    $tokens['node']['crl-menupath-raw'] = t('A customized version of the [menupath-raw] token for the CRL menus that puts certain items (e.g. GRN) at the top level.');
  }

  return $tokens;
}

/**
 * Implementation of hook_token_values().
 */
function crl_helpers_token_values($type, $object = NULL) {
  $values = array();
  switch ($type) {
    case 'global':
      break;  
    case 'node':
      // Node tokens here.
      $node = $object;

      // This code is from token_node.inc:node_token_values() in the token 
      // token module.

      // Try to get the menu data.
      $mlid = db_result(db_query("SELECT mlid FROM {menu_links} WHERE link_path = '%s'", 'node/'. $node->nid));

      // Now get the menu related information.
      if (!empty($mlid) || !empty($node->menu['mlid']) || !empty($node->menu['plid'])) {
        $menu_link = menu_link_load($mlid);
        $menus = menu_get_menus();
        $menu = isset($menus[$menu_link['menu_name']]) ? $menus[$menu_link['menu_name']] : '';
        $trail_raw = _menu_titles($menu_link, $node->nid);

        $trail = array();
        foreach ($trail_raw as $title) {
          $trail[] = check_plain($title);
        }

        // This is how node_token generates the default tokens
        $value_menupath            = implode('/', $trail);
        $value_menupath_raw        = implode('/', $trail_raw);
        $value_menu                = check_plain($menu);
        $value_menu_raw            = $menu;
        $value_menu_link_title     = check_plain($menu_link['title']);
        $value_menu_link_title_raw = $menu_link['link_title'];
      }
      else {
        $value_menupath            = '';
        $value_menupath_raw        = '';
        $value_menu                = '';
        $value_menu_raw            = '';
        $value_menu_link_title     = '';
        $value_menu_link_title_raw = '';
      }
      // NOTE: You'll have to change this if statement if the menu that contains 
      // events ever changes.
      if ($menu_link['menu_name'] == 'menu-crl-events') {
        // If this item is in the events menu
        $value_crl_menupath_raw = $value_menupath_raw; // Start with the default ['menupath-raw']
        if (!empty($node->menu['plid'])) {
          // If the node has a parent in the menu, we want the token to be of
          // the form: Events/PARENT_NID/Title
          $plid = $node->menu['plid'];
          $parent_menu_link = menu_link_load($plid);
          $parent_link_path_parts = preg_split("/\//", $parent_menu_link['link_path']); 
          if (count($parent_link_path_parts) == 2 && 
              $parent_link_path_parts[0] == 'node') {
            $parent_nid = $parent_link_path_parts[1];
            $value_crl_menupath_raw = 'Events/' . $parent_nid . '/' . $value_menu_link_title_raw;
          }
        }
      }
      else {
        //$value_crl_menupath_raw = $value_menupath_raw; // Start with the default ['menupath-raw']
        //$value_crl_menupath_raw = str_replace('Forum/Area Studies', 'Area Studies',  $value_crl_menupath_raw);
        //$value_crl_menupath_raw = str_replace('Forum/GRN', 'GRN', $value_crl_menupath_raw);
        //$value_crl_menupath_raw = str_replace('Collaborations/Collaborative Digitization', 'Collaborative Digitization', $value_crl_menupath_raw);
      }

      $values['crl-menupath-raw'] = $value_crl_menupath_raw;    
      break;
  }

  return $values;
}

/**
 * Get a Topic Guide node's term object for it's Topic vocabulary taxonomy term.
 *
 * @param $node - Topic Guide node.
 *
 * @return Taxonomy term object for the node's Topic vocabulary taxonomy term. NULL 
 *         if no such term exists.
 */
function crl_helpers_get_topic_guide_topic_term($node) {
  if (isset($node->taxonomy)) {
    foreach ($node->taxonomy as $term) {
      if ($term->vid == CRL_HELPERS_TOPIC_VID) {
        return $term;
      }
    }
  }

  return NULL; 
}

/**
 * Get a Topic Guide node's Topic vocabulary taxonomy term.
 *
 * @param $node - Topic guide node.
 *
 * @return String containing Topic vocabulary term name or NULL if there isn't one.
 *
 */
function crl_helpers_get_topic_guide_topic_name($node) {
  $term = crl_helpers_get_topic_guide_topic_term($node);
  if ($term !== NULL) {
    return $term->name;
  }
  else {
    return NULL;
  }
}

/**
 * Get a Topic Guide node's Topic vocabulary taxonomy term ID.
 *
 * @param $node - Topic guide node.
 *
 * @return  Integer containing Topic vocabulary term TID or NULL if there isn't one.
 *
 */
function crl_helpers_get_topic_guide_topic_tid($node) {
  $term = crl_helpers_get_topic_guide_topic_term($node);
  if ($term !== NULL) {
    return $term->tid;
  }
  else {
    return NULL;
  }
}


/*****************************************************************************
 * Manage institution pick-lists
 *****************************************************************************/

/**
* Implementation of hook_webform_select_options_info().
* See webform/webform_hooks.php for further information on this hook in the Webform API.
*/
function crl_helpers_webform_select_options_info() {
  $items = array();
  $items['institutions'] = array(
    'title' => t('Institutions'),
    'options callback' => 'crl_helpers_options_institutions_list'
  );
  return $items; 
}

  
// Callback to build institutions list from variable string. This can be called 
// though weboform hook and directly (default options on profile form, etc.).
function crl_helpers_options_institutions_list() {
  // If we are using salesforce integartion we will get the list from the
  // variable that module populates
  if (module_exists('crl_sf_sync')) {
    return variable_get('crl_sf_sync_institutions_array', array());
  }
  // If not, we have to get the values from a statically maintained variable
  $institutions = variable_get('crl_institutions', 'key|value');
  $institutions_array = array();
  $lines = explode("\n", $institutions);
  foreach ($lines as $line) {
    $line = trim($line);
    list($key, $value) = explode("|", $line);
    $institutions_array += array($key => $value);
  }
  return $institutions_array;
}


/*****************************************************************************
 * Add custom "grouped" structure to create content page
 *****************************************************************************/

// Setup our own theme override for create content screen
function crl_helpers_theme_registry_alter(&$theme_registry) {
  if (!empty($theme_registry['node_add_list'])) {
    $theme_registry['node_add_list']['function'] = 'theme_crl_helpers_node_add_list';
  }
}

// Theme override for create content screen
function theme_crl_helpers_node_add_list($content) {
  $output = '';
  if ($content) {
    // Group types into multi-dimentional array
    $grouped_items = array(0 => array('title' => 'Other'));
    $groups = array(0 => 'Other');
    foreach ($content as $c_type_key => $value) {
      $title_parts = explode(':', $value['title']);
      if (!empty($title_parts) && count($title_parts) == 2) {
        $title_parts[0] = trim($title_parts[0]);
        $value['title'] = str_replace($title_parts[0], '', $value['title']);
        $value['title'] = trim(str_replace(':', '', $value['title']));
        $group_key = array_search($title_parts[0], $groups);
        if ($group_key) {
          $grouped_items[$group_key]['types'][$c_type_key] = $value;
        }
        else {
          $groups[] = $title_parts[0];
          $groups_count = count($groups);
          $grouped_items[]['types'] = array($c_type_key => $value);
          $grouped_items[$groups_count - 1]['title'] = $title_parts[0];       
        }
      }
      else {
        $grouped_items[0]['types'][$c_type_key] = $value;
      }
    }
    // Put "other" group at end
    if (isset($grouped_items[0]['types'])) {
      $other = $grouped_items[0];
      unset($grouped_items[0]);
      $grouped_items[] = $other;
    }
    else {
      unset($grouped_items[0]);
    }
    // Render the grouped_items list
    foreach ($grouped_items as $group) {
      $output .= '<h2>' . $group['title'] . '</h2>';
      $output .= '<dl class="node-type-list">';
      foreach ($group['types'] as $item) {
        $output .= '<dt>' . l($item['title'], $item['href'], $item['localized_options']) . '</dt>';
        $output .= '<dd>' . filter_xss_admin($item['description']) . '</dd>';   
      }
      $output .= '</dl>';
    }
  }
  return $output;
}


/*****************************************************************************
 * Functionality for 2-level expanded menu blocks
 *****************************************************************************/

/**
* Implementation of hook_menu_block_tree_alter().
*/
function crl_helpers_menu_block_tree_alter(&$tree, &$config) {
  if (variable_get('crl_expand_menublock', FALSE) && !$config['expanded']) {
    $tree = _crl_helpers_menu_tree_page_data($config['menu_name']);
    // Set menu to be "expanded". We have already rendered the meny with the
    // correct number of branches open via the call above, but we want menu
    // block to think this menu is expanded from this point forward so that it
    // does not do any trimming to the ends of our branches.
    $config['expanded'] = TRUE;
  }
}

// This function is essentially a small rewtire of the core 
// menu_tree_page_data(). This verson has an addition that does one extra query
// to gather all the children of the children of the current item and ensure
// they are also added to the tree that is to be built.
function _crl_helpers_menu_tree_page_data($menu_name = 'navigation') {
  static $tree = array();

  // Load the menu item corresponding to the current page.
  if ($item = menu_get_item()) {
    // Generate a cache ID (cid) specific for this page.
    // $cid= 'links:'. $menu_name .':page-cid:'. $item['href'] .':'. (int)$item['access'];
    $cid = 'links:'. $menu_name .'_special:page-cid:'. $item['href'] .':'. (int)$item['access'];

    if (!isset($tree[$cid])) {
      // If the static variable doesn't have the data, check {cache_menu}.
      $cache = cache_get($cid, 'cache_menu');
      if ($cache && isset($cache->data)) {
        // If the cache entry exists, it will just be the cid for the actual data.
        // This avoids duplication of large amounts of data.
        $cache = cache_get($cache->data, 'cache_menu');
        if ($cache && isset($cache->data)) {
          $data = $cache->data;
        }
      }
      // If the tree data was not in the cache, $data will be NULL.
      if (!isset($data)) {
        // Build and run the query, and build the tree.
        if ($item['access']) {
          // Check whether a menu link exists that corresponds to the current path.
          $args = array($menu_name, $item['href']);
          $placeholders = "'%s'";
          if (drupal_is_front_page()) {
            $args[] = '<front>';
            $placeholders .= ", '%s'";
          }
          $parents = db_fetch_array(db_query("SELECT p1, p2, p3, p4, p5, p6, p7, p8 FROM {menu_links} WHERE menu_name = '%s' AND link_path IN (". $placeholders .")", $args));
          if (empty($parents)) {
            // If no link exists, we may be on a local task that's not in the links.
            // TODO: Handle the case like a local task on a specific node in the menu.
            $parents = db_fetch_array(db_query("SELECT p1, p2, p3, p4, p5, p6, p7, p8 FROM {menu_links} WHERE menu_name = '%s' AND link_path = '%s'", $menu_name, $item['tab_root']));
          }
          // We always want all the top-level links with plid == 0.
          $parents[] = '0';

          // Use array_values() so that the indices are numeric for array_merge().
          $args = $parents = array_unique(array_values($parents));
          $placeholders = implode(', ', array_fill(0, count($args), '%d'));
          $expanded = variable_get('menu_expanded', array());
          // Check whether the current menu has any links set to be expanded.
          if (in_array($menu_name, $expanded)) {
            // Collect all the links set to be expanded, and then add all of
            // their children to the list as well.
            do {
              $result = db_query("SELECT mlid FROM {menu_links} WHERE menu_name = '%s' AND expanded = 1 AND has_children = 1 AND plid IN (". $placeholders .') AND mlid NOT IN ('. $placeholders .')', array_merge(array($menu_name), $args, $args));
              $num_rows = FALSE;
              while ($item = db_fetch_array($result)) {
                $args[] = $item['mlid'];
                $num_rows = TRUE;
              }
              $placeholders = implode(', ', array_fill(0, count($args), '%d'));
            } while ($num_rows);
          }
          array_unshift($args, $menu_name);
          
          // Begin addition to initial function ------------------------------
          // Set an extra level to be expanded. We do this by adding the mlids
          // of the CHILDREN of our current item to the arg list
          $current_item = array_pop(menu_get_active_trail());
          $current_mlid = $current_item['mlid'];
          // Get children of current item that have children
          if (!empty($current_mlid)) {
            $result2 = db_query("SELECT mlid FROM {menu_links} WHERE menu_name = '" . $menu_name . "' AND has_children = 1 AND plid = " . $current_mlid . " AND mlid != " . $current_mlid);
            while ($item2 = db_fetch_array($result2)) {
              // Make sure the mlid wasn't already added as an "expanded" item
              // from above, and if not, add to args.
              if (!in_array($item2['mlid'], $args)) {
                $args[] = $item2['mlid'];
              }
            }
            // Also re-adjust placeholders to accomodate any new arg additions
            $placeholders = implode(', ', array_fill(0, count($args), '%d')); 
          }
          // End adddition to initial function --------------------------------
             
        }
        else {
          // Show only the top-level menu items when access is denied.
          $args = array($menu_name, '0');
          $placeholders = '%d';
          $parents = array();
        }
        // Select the links from the table, and recursively build the tree. We
        // LEFT JOIN since there is no match in {menu_router} for an external
        // link.
        $data['tree'] = menu_tree_data(db_query("
          SELECT m.load_functions, m.to_arg_functions, m.access_callback, m.access_arguments, m.page_callback, m.page_arguments, m.title, m.title_callback, m.title_arguments, m.type, m.description, ml.*
          FROM {menu_links} ml LEFT JOIN {menu_router} m ON m.path = ml.router_path
          WHERE ml.menu_name = '%s' AND ml.plid IN (". $placeholders .")
          ORDER BY p1 ASC, p2 ASC, p3 ASC, p4 ASC, p5 ASC, p6 ASC, p7 ASC, p8 ASC, p9 ASC", $args), $parents);
        $data['node_links'] = array();
        menu_tree_collect_node_links($data['tree'], $data['node_links']);
        // Cache the data, if it is not already in the cache.
        $tree_cid = _menu_tree_cid($menu_name, $data);
        if (!cache_get($tree_cid, 'cache_menu')) {
          cache_set($tree_cid, $data, 'cache_menu');
        }
        // Cache the cid of the (shared) data using the page-specific cid.
        cache_set($cid, $tree_cid, 'cache_menu');
        //cache_set($cid_old, $tree_cid, 'cache_menu');
      }
      // Check access for the current user to each item in the tree.
      menu_tree_check_access($data['tree'], $data['node_links']);
      $tree[$cid] = $data['tree'];
    }
    return $tree[$cid];
  }

  return array();
}


/*****************************************************************************
 * Misc Helpers (Isolated functions)
 *****************************************************************************/


/**
 * Implementation of hook_wysiwyg_editor_settings_alter().
 * 
 * Quick method to override some global config.js settings for ckeditor
 */
function crl_helpers_wysiwyg_editor_settings_alter(&$settings, $context) {
  if ($context['profile']->editor == 'ckeditor') {
    //$settings['scayt_autoStartup'] = true;
    $settings['bodyClass'] = 'contents ckeditor_editor';
    $settings['bodyId'] = 'pagebody';
    $setting['height'] = 200;
  }
}


/* Use nodeapi to check for badly formatted links upon each page save and
 * preview (catch internal links that are formatted as external links).
 */
function crl_helpers_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  if ($op == 'validate') {
    $bad_links = array();
    // Loop through node object looking for fields
    foreach ($node as $var => $value) {
      $to_check = FALSE;
      if ($var == 'body') {
        $to_check = $value;
      }
      elseif (strpos($var, "field_") === 0) {
        if (is_string($value[0]['value'])) {
          $to_check = $value[0]['value'];
        }
      }
      if ($to_check) {
        // Find internal links that are absolute
        $matches = preg_match_all('/href\=\"http:\/\/(www\.crl\.edu.*?)\"/i', $to_check, $matches_array);
        if ($matches) {
          $bad_links[$var] = $matches_array[1];
        }
      }
    }
    // If we found "bad" links, set a message to the editor
    if (!empty($bad_links) && $node->created > 1349049600) { // Created after Oct 1, 2012
      $message = t('<strong>Warning:</strong> The <em>internal</em> links listed below appear to be formatted incorrectly. Please consider revising these links so that they use an <em>internal</em> path structure. For page links the internal path structure is shown in green text at the bottom of the page that you want to link to, and for file links and images you may need to simply exclude the "http://www.crl.edu" part. This is just a notice, not an indication that anything is "broken".<ul>');
      foreach($bad_links as $field => $value) {
        $field = str_replace('field_', '', $field);
        foreach($value as $link) {
          $message .= '<li><strong>' . $field . ':</strong> <a target="_blank" href="http://' . $link . '">'. $link . '</a></li>';
        }
      }
      $message .= '</ul>';
      drupal_set_message($message, 'warning');
    }
  }
}


/**
 * Implementation of hook_menu_alter().
 */
function crl_helpers_menu_alter(&$items) {
  $items['node/%node/track']['type'] = MENU_CALLBACK;
  // Disable the default RSS feed.
  unset($items['rss.xml']);
}


/**
 * Use the phpsniff library to determine if the client's browser is supported. 
 */
function crl_helpers_is_unsupported_browser() {
  static $is_unsupported_browser = NULL;
  if (is_null($is_unsupported_browser)) {
    $phpsniff_path = drupal_get_path('module', 'crl_helpers') . '/phpsniff/phpSniff.class.php';
    if (file_exists($phpsniff_path)) { 
      // Load the phpsniff library and use it.
      require_once $phpsniff_path;
      $client = new phpSniff($_REQUEST['UA']);

      if ($client->browser_is('ie')) {
        if ($client->browser_is('ie7+')) {
          $is_unsupported_browser = FALSE;
        }
        else {
          $is_unsupported_browser = TRUE;
        }
      }
      else {
        $is_unsupported_browser = FALSE;
      }
    }
  }

  return $is_unsupported_browser;
}


/**
* This function adds a "reset" button to the views defined in $exposed_views
* Implementation of hook_form_alter().
*/
function crl_helpers_form_alter(&$form, $form_state, $form_id) {
  if ($form_id == 'views_exposed_form') {
    $exposed_views = array('page_assignments');
    if (in_array($form_state['view']->name, $exposed_views)) {
      $current_display = $form_state['view']->current_display;
      $form['reset'] = array(
        '#type' => 'markup',
        '#value' => '<input class="form-button" type="reset" value="Reset" onClick="javascript:window.location=\'/'. 
          $form_state['view']->display[$current_display]->display_options['path'] .'\';" />',
      );
    }
  }
}


// Callback meny function that acts as "traffic control" for PP SSO.
function crl_helpers_pp_sso() {
  global $user;
  $pp_salt = "Hkui8lhL";
  $user_maps = variable_get('crl_pp_sso_user_map', 'key|value');
  $user_maps_array = array();
  $lines = explode("\n", $user_maps);
  foreach ($lines as $line) {
    $line = trim($line);
    list($key, $value) = explode("|", $line);
    $user_maps_array += array($key => $value);
  }
  if ($user->uid) {
    $match = array_search($user->uid, $user_maps_array);
    if ($match !== FALSE) {
      $ip = ip_address();
      // @TODO: Remove... for testing environemnts set a working ip
      if ($ip == '::1' || $ip == '127.0.0.1') {
        $ip = '192.168.1.92';
      }
      $token = md5($ip . $match . $pp_salt);
      $link = variable_get('crl_pp_sso_remote_url', 'http://www-apps.crl.edu/content/pp/ballot2.asp') . '?inst=' . $match . '&token=' . $token;
      drupal_goto($link);
      //$message = 'your login is:<br/><a href="' . $link . '">' . $link . '</a>';
    }
    else {
      $message = t("Message for users who are logged-in but can't access PP goes here");
    }
  }
  else {
    $message = t("Message for non-logged-in users goes here");;
  }
  return $message;
}


// Helper truncate function
function crl_truncate($name){
	  $names = explode(" ", $name);
	  $names[1] = substr($names[1], 0, 1);
	  $edited = $names[0] . " " . $names[1] . ".";
	  return $edited;
}