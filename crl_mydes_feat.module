<?php
/**
 * @file
 * Code for the My eDesiderata feature.
 */

include_once 'crl_mydes_feat.features.inc';

define('CRL_WATCH_FLAG', 'base_node_watch');


/**
 * Implements hook_menu().
 */
function crl_mydes_feat_menu() {
  $items['me'] = array(
    'title' => 'meDesiderata',
    'description' => 'meDesiderata Dashboard.',
    'page callback' => 'crl_mydes_feat_dashboard_page',
    'access callback' => TRUE,
  );
  return $items;
}


/**
 * Page callback for meDesiderata dashboard page.
 * 
 * @todo Theme the output.
 */
function crl_mydes_feat_dashboard_page() {
  $text = '';
  // Add generic text to always appear at the top of the page.
  $text .= '<p>' . t('<span class="m-edes">m</span>eDesiderata is your space to track resources of direct interest to you. Individual resources or sets of resources you selected to watch will be listed below. You may also recieve automated email updates based on these selections.') . '</p>';
  // Add content that is specific to login when the user does not have access
  // to the meDes features themselves.
  if (!user_access('crl access member features')) {
    global $user;
    if ($user->uid) {
      $text .= '<p><strong>' . t('You logged in as a non-member. This means that some meDesiderata features are not available.') . '</strong></p>';
    }
    else {
      // Add login block. We could place this with the normal block system or
      // context, but this is a bit easier.
      $text .= render(module_invoke('user', 'block_view', 'login'));
    }
  }
  return $text;
}


/**
 * Implements hook_theme().
 */
function crl_mydes_feat_theme() {
  return array(
    // Theme hook to generate a collapsable saved search box.
    'crl_mydes_feat_save_search_form' => array(
      'variables' => array('block' => array()),
      'path' => drupal_get_path('module', 'crl_mydes_feat') . '/themes',
      'file' => 'crl_mydes_feat.theme.inc',
    ),
  );
}


/**
 * Implements hook_block_info().
 */
function crl_mydes_feat_block_info() {
  // Block for use on resources pages to flag/watch a resource.
  $blocks['crl_mydes_feat_flag'] = array(
    'info' => t('Watch Resource via My eDesiderata'), 
    'cache' => DRUPAL_NO_CACHE,
  );
  // Block for My eDes page to allow users to control their mail settings.
  $blocks['crl_mydes_email_settings'] = array(
    'info' => t('Manage My eDesiderata mail settings'), 
    'cache' => DRUPAL_NO_CACHE,
  );
  return $blocks;
}


/**
 * Implements hook_block_view().
 */
function crl_mydes_feat_block_view($delta = '') {
  $block = array();
  switch ($delta) {
    case 'crl_mydes_feat_flag':
      global $user;
      $nid = arg(1);
      $node = node_load($nid);
      // Make sure block should be visible
      if (isset($node->type) && $node->type == 'resource' && user_access('crl access member features')) {
        $block['subject'] = t('Watch this Resource');
        $block['content'] = array('#markup' => crl_mydes_feat_generate_widget($node));
      }
      break;
    case 'crl_mydes_email_settings':
      if (user_access('crl access member features')) {
        $block['subject'] = t('My Email Notification Settings');
        $block['content'][] = array(
          'form' => drupal_get_form('crl_mydes_feat_email_settings_form'),
        );
      }
  }
  return $block;
}


/**
 * Utility to generate a "watch resource" form option (usually to be shown in
 * a block).
 * 
 * @param object $node
 *   The resource node that can be watched.
 * @return string
 *   Returns markup for the watch resource form.
 */
function crl_mydes_feat_generate_widget($node) {
  $output = '<p>' . t('By watching this resource you can monitor its activity in !link.', array('!link' => l(t('meDesiderata'), 'me'))) . '</p>';
  $flag_link = flag_create_link(CRL_WATCH_FLAG, $node->nid);
  return $output . $flag_link;
}


/**
 * Utility to generate a collapsible "save search" form (wrapping the existing
 * "save search" block) that can be added to a filtered resource index.
 * 
 * @return string
 *   Returns markup for the collapsible form.
 */
function crl_mydes_feat_build_saved_search_form() {
  $output = '';
  if (user_access('crl access member features')) {
    // Add the saved search block.
    $saved_searches = search_api_saved_searches_settings_load_multiple(FALSE, array('enabled' => TRUE));
    if (!empty($saved_searches)) {
      $saved_search = reset($saved_searches);
      $block = module_invoke('search_api_saved_searches', 'block_view', $saved_search->delta);
      drupal_add_js(drupal_get_path('module', 'crl_mydes_feat') .'/js/crl_mydes_feat.js', 'file');
      $output .= theme('crl_mydes_feat_save_search_form', array('block' => $block));
    }
  }
  return $output;
}


/**
 * Implements hook_form_alter().
 */
function crl_mydes_feat_form_alter(&$form, &$form_state, $form_id) {
  // Make some alterations to the "save search" form.
  if ($form_id == 'search_api_saved_searches_save_form' || $form_id == 'search_api_saved_searches_search_edit_form') {
    $form['top_note'] = array(
      '#markup' => '<hr/><p>' . t('You can save this filter selection as a watchset and track future additions to these results. Manage your watchsets and email notification options in meDesiderata.') . '</p>',
      '#weight' => -10,
    );
    $form['name']['#default_value'] = '';
    $form['name']['#description'] = t('Give this group a name by which it can be later accessed within meDesiderata');
    // If the form is presented out side of the normal user configuration pages
    // for the search api module, we manually control the notification interval.
    $args = arg();
    if ($args[0] !== 'search-api') {
      $form['notify_interval']['#type'] = 'hidden';
      $form['notify_interval']['#value'] = crl_mydes_feat_email_settings_user_setting(TRUE);
    }
    else {
      $form['notify_interval']['#description'] = t('Select how frequently you would like to be notifed via email when resources are <em>added</em> that match this filter criteria');
    }
    $form['submit']['#value'] = t('Watch');
  }
}


/**
 * Form definition for the global My eDesiderata mail settings controls.
 */
function crl_mydes_feat_email_settings_form() {
  $form = array();
  // Get the options from the sub email frequency module, but remove the
  // "immediate" one.
  $options = message_subscribe_email_frequency_allowed_values();
  if (isset($options[MESSAGE_SUBSCRIBE_EMAIL_FREQUENCY_IMMEDIATE])) {
    unset($options[MESSAGE_SUBSCRIBE_EMAIL_FREQUENCY_IMMEDIATE]);
  }
  $form['intro'] = array(
    '#markup' => '<p><a id="email"></a>' . t('Notifications about updates in your watchlist or additions to a watchset will be emailed at the interval you specify.') . '</p>',
  );
  $form['email_setting'] = array(
    '#type' => 'select',
    '#title' => t('Email Notification Interval'),
    '#default_value' => crl_mydes_feat_email_settings_user_setting(),
    '#options' => $options,
  );
  $form['submit'] = array('#type' => 'submit', '#value' => t('Submit'));
  $form['#submit'][] = 'crl_mydes_feat_email_settings_form_submit_handler';
  return $form;
}


/**
 * Submit handler for the crl_mydes_feat_email_settings_form form.
 * 
 * This provides custom processing for changes to email preferences and ensures
 * that BOTH watchlist digest and saved search mail preferences are changed.
 */
function crl_mydes_feat_email_settings_form_submit_handler($form, &$form_state) {
  global $user;
  $digest_updated = $search_updated = FALSE;
  // Lets be very careful about gracefully cathing any errors that may happen
  // while updating. We REALLY don't want a WSOD or something like that here.
  try {
    $account = user_load($user->uid); // Load fields
    $wrapper = entity_metadata_wrapper('user', $account);
    // Save the digest settings for the user.
    if (isset($wrapper->message_subscribe_email_freq)) {
      $wrapper->message_subscribe_email_freq->set($form_state['values']['email_setting']);
      $wrapper->save();
      $digest_updated = TRUE;
    }
    // Save the saved search intervals for the user across ALL thier saved
    // searches.
    $result = db_update('search_api_saved_search')
      ->condition('uid', $wrapper->getIdentifier())
      ->fields(array('notify_interval' => crl_mydes_feat_email_settings_user_setting(TRUE, $form_state['values']['email_setting'])))
      ->execute();
    if (!is_null($result)) {
      $search_updated = TRUE;
    }
  }
  catch (Exception $e) {
    $message = 'Could not save email changes: !message in %function (line %line of %file).';
    watchdog_exception('crl_mydes_feat', $e, $message);
  }
  // Make sure we were successfull with the updates. If there was a problem we
  // log it as critical and display a message to the user that reassures them
  // we'll make things right. It's important to note that users may encounter
  // these messages in multiple places, includiing the unsubscibe interface.
  if ($digest_updated && $search_updated) {
    drupal_set_message(t('Your meDesiderata email settings have been updated'));
  }
  else {
    drupal_set_message(t('There was a problem updating your email settings. This problem has been logged and CRL staff will attempt to manually update your preferences.'), 'error');
    watchdog('crl_mydes_feat', 'meDesiderata email preference for user %name did not update. Value to set: %value', array('%name' => $user->name, '%value' => $form_state['values']['email_setting']), WATCHDOG_CRITICAL);
  }
}


/**
 * Helper to get the current My eDesiderata email setting for a user, or to
 * convert a known setting to seconds.
 * 
 * @param boolean $seconds
 *   Whether or not to report the current setting in seconds as opposed to a
 *   key value (such as "day" or "week").
 * @param string $known_setting
 *   Optional "known" value (in key form) for a user's email setting. If this is
 *   set the user's current setting will not be querued. This is useful in
 *   conjunction with the $seconds value for simply converting a known key value
 *   into seconds.
 * @return mixed
 *   Returns the user's current email setting. This will be in the form of a key
 *   value (such as "day" or "week") unless $seconds is TRUE in which case the
 *   value will be returned as an integer number of seconds.
 */
function crl_mydes_feat_email_settings_user_setting($seconds = FALSE, $known_setting = NULL) {
  // Get default value from the current user settings if it's not passed in.
  if (isset($known_setting)) {
    $current_setting = $known_setting;
  }
  else {
    global $user;
    $account = user_load($user->uid); // Load fields
    $wrapper = entity_metadata_wrapper('user', $account);
    $current_setting = isset($wrapper->message_subscribe_email_freq) ? $wrapper->message_subscribe_email_freq->value() : MESSAGE_SUBSCRIBE_EMAIL_FREQUENCY_NEVER;
  }
  if ($seconds) {
    if (strpos($current_setting, 'day') !== FALSE) {
      $current_setting = 60*60*24;
    }
    elseif (strpos($current_setting, 'week') !== FALSE) {
      $current_setting = 60*60*24*7;
    }
    else {
      // A default value of -1 means "never".
      $current_setting = -1;
    }
  }
  return $current_setting;
}


function crl_mydes_feat_preprocess_menu_link(&$vars) {
  $element = $vars['element'];
  $element['#title'] = crl_mydes_feat_style_name($element['#title']);
  if ($element['#title'] != $vars['element']['#title']) {
    $vars['element']['#title'] = $element['#title'];
    $vars['element']['#localized_options']['html'] = TRUE;
  }
}


function crl_mydes_feat_preprocess_delta_blocks_page_title(&$vars) {
  $vars['page_title'] = crl_mydes_feat_style_name($vars['page_title']);
}


function crl_mydes_feat_style_name($text) {
  return str_ireplace('meDesiderata', '<span class="m-edes">m</span>eDesiderata', $text);
}
